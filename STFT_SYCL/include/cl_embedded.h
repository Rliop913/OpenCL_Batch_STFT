
#pragma once
//generated with python code
#include <string>
class cl_embed {
    public:
    #ifndef NO_EMBEDDED_CL
std::string bitreverse_stft = 
	"//DEBUG OR RELEASE\n"
	"#define DO_DEBUG\n"
	"\n"
	"\n"
	"//Front declaration\n"
	"//declare here, implement later\n"
	"\n"
	"\n"
	"\n"
	"int reverseBits(int num, int radix_2_data) {\n"
	"    int reversed = 0;\n"
	"    for (int i = 0; i < radix_2_data; ++i) {\n"
	"        reversed = (reversed << 1) | (num & 1);\n"
	"        num >>= 1;\n"
	"    }\n"
	"    return reversed;\n"
	"}\n"
	"__kernel void bitreverse_stft(__global float2* frame, __global float2* out_frame, int radix_2)\n"
	"{\n"
	"    int powed = (int)pow(2.0,radix_2);\n"
	"    long myid = get_global_id(0);\n"
	"    long id_quot = myid / powed;\n"
	"    int id_rem = myid%powed;\n"
	"    long calced_id = id_quot*powed + reverseBits(id_rem,radix_2);\n"
	"    out_frame[myid].x = frame[calced_id].x;\n"
	"    out_frame[myid].y = 0.0;\n"
	"\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#ifndef DO_DEBUG\n"
	"//Release Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_RELEASE\n"
	"\n"
	"\n"
	"\n"
	"#ifdef DO_DEBUG\n"
	"//Debug Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_DEBUG\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string bitreverse_stft = 
	"CL_C_kernel_files/bit_reverse_STFT.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string butterfly_stft = 
	"\n"
	"//2 component vector to hold the real and imaginary parts of a complex number:\n"
	"typedef float2 cfloat;\n"
	"\n"
	"#define I ((cfloat)(0.0, 1.0))\n"
	"\n"
	"\n"
	"/*\n"
	" * Return Real (Imaginary) component of complex number:\n"
	" */\n"
	"inline float  real(cfloat a){\n"
	"     return a.x;\n"
	"}\n"
	"inline float  imag(cfloat a){\n"
	"     return a.y;\n"
	"}\n"
	"\n"
	"/*\n"
	" * Get the modulus of a complex number (its length):\n"
	" */\n"
	"inline float cmod(cfloat a){\n"
	"    return (sqrt(a.x*a.x + a.y*a.y));\n"
	"}\n"
	"\n"
	"/*\n"
	" * Get the argument of a complex number (its angle):\n"
	" * http://en.wikipedia.org/wiki/Complex_number#Absolute_value_and_argument\n"
	" */\n"
	"inline float carg(cfloat a){\n"
	"    if(a.x > 0){\n"
	"        return atan(a.y / a.x);\n"
	"\n"
	"    }else if(a.x < 0 && a.y >= 0){\n"
	"        return atan(a.y / a.x) + M_PI;\n"
	"\n"
	"    }else if(a.x < 0 && a.y < 0){\n"
	"        return atan(a.y / a.x) - M_PI;\n"
	"\n"
	"    }else if(a.x == 0 && a.y > 0){\n"
	"        return M_PI/2;\n"
	"\n"
	"    }else if(a.x == 0 && a.y < 0){\n"
	"        return -M_PI/2;\n"
	"\n"
	"    }else{\n"
	"        return 0;\n"
	"    }\n"
	"}\n"
	"\n"
	"/*\n"
	" * Multiply two complex numbers:\n"
	" *\n"
	" *  a = (aReal + I*aImag)\n"
	" *  b = (bReal + I*bImag)\n"
	" *  a * b = (aReal + I*aImag) * (bReal + I*bImag)\n"
	" *        = aReal*bReal +I*aReal*bImag +I*aImag*bReal +I^2*aImag*bImag\n"
	" *        = (aReal*bReal - aImag*bImag) + I*(aReal*bImag + aImag*bReal)\n"
	" */\n"
	"inline cfloat  cmult(cfloat a, cfloat b){\n"
	"    return (cfloat)( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
	"}\n"
	"\n"
	"\n"
	"/*\n"
	" * Divide two complex numbers:\n"
	" *\n"
	" *  aReal + I*aImag     (aReal + I*aImag) * (bReal - I*bImag)\n"
	" * ----------------- = ---------------------------------------\n"
	" *  bReal + I*bImag     (bReal + I*bImag) * (bReal - I*bImag)\n"
	" * \n"
	" *        aReal*bReal - I*aReal*bImag + I*aImag*bReal - I^2*aImag*bImag\n"
	" *     = ---------------------------------------------------------------\n"
	" *            bReal^2 - I*bReal*bImag + I*bImag*bReal  -I^2*bImag^2\n"
	" * \n"
	" *        aReal*bReal + aImag*bImag         aImag*bReal - Real*bImag \n"
	" *     = ---------------------------- + I* --------------------------\n"
	" *            bReal^2 + bImag^2                bReal^2 + bImag^2\n"
	" * \n"
	" */\n"
	"inline cfloat cdiv(cfloat a, cfloat b){\n"
	"    return (cfloat)((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y), (a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y));\n"
	"}\n"
	"\n"
	"\n"
	"cfloat twiddle(int high, int low)\n"
	"{\n"
	"    cfloat temp;\n"
	"    float angle = 2.0*((float)high/(float)low);\n"
	"    temp.x = cospi(angle);\n"
	"    temp.y = -1.0*sinpi(angle);\n"
	"    return temp;\n"
	"}\n"
	"\n"
	"long2 indexer(const long ID,const int stage)\n"
	"{\n"
	"    long2 temp;\n"
	"    long powed = pow(2.0, stage);\n"
	"    temp.x = (ID%(powed))+powed*2*(ID/powed);\n"
	"    temp.y = temp.x+powed;\n"
	"    return temp;\n"
	"}\n"
	"\n"
	"\n"
	"__kernel void butterfly_stft(__global float2* in_frame, __global float2* out_frame, int radix_2, int stage)\n"
	"{\n"
	"    long powed_stage = (long)pow(2.0,stage);\n"
	"    long myid = get_global_id(0);\n"
	"    long2 origin_pair=indexer(myid,stage);\n"
	"    cfloat this_twiddle = twiddle(myid%powed_stage,powed_stage*2);\n"
	"    this_twiddle = cmult(in_frame[origin_pair.y],this_twiddle);\n"
	"    out_frame[origin_pair.x]=in_frame[origin_pair.x]+this_twiddle;\n"
	"    out_frame[origin_pair.y]=in_frame[origin_pair.x]-this_twiddle;\n"
	"    \n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string butterfly_stft = 
	"CL_C_kernel_files/butterfly_STFT.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string DaC = 
	"\n"
	"__kernel void DaC(__global float* in_frame, __global float* out_frame)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    int2 my_index;\n"
	"    my_index.x = (myid*2);\n"
	"    my_index.y = my_index.x+1;\n"
	"    out_frame[myid]= in_frame[my_index.x]+in_frame[my_index.y];\n"
	"    \n"
	"}\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string DaC = 
	"CL_C_kernel_files/DaC.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string integ_DaC = 
	"//DEBUG OR RELEASE\n"
	"#define DO_DEBUG\n"
	"\n"
	"\n"
	"//Front declaration\n"
	"//declare here, implement later\n"
	"\n"
	"\n"
	"//Kernel entry point\n"
	"__kernel void integ_DaC(__global float* low_in, __global float* mid_in, __global float* high_in, __global float3* integ_out)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    integ_out[myid].x=low_in[myid];\n"
	"    integ_out[myid].y=mid_in[myid];\n"
	"    integ_out[myid].z=high_in[myid];\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#ifndef DO_DEBUG\n"
	"//Release Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_RELEASE\n"
	"\n"
	"\n"
	"\n"
	"#ifdef DO_DEBUG\n"
	"//Debug Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_DEBUG\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string integ_DaC = 
	"CL_C_kernel_files/integrate_DaC.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string overlap = 
	"//DEBUG OR RELEASE\n"
	"#define DO_DEBUG\n"
	"\n"
	"\n"
	"//Front declaration\n"
	"//declare here, implement later\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"//Kernel entry point\n"
	"__kernel void overlap(__global float* frame_in, __global float2* frame_out, int window_frame,const int overlap_frame, int2 acc_able_frame, int front_side_zero_padding_size)\n"
	"{\n"
	"\n"
	"    unsigned long myid = get_global_id(0);\n"
	"    unsigned long quot =myid/window_frame;\n"
	"\n"
	"    int rem = myid % window_frame;\n"
	"    unsigned long my_index = quot*overlap_frame + rem;\n"
	"    float will_write;\n"
	"    unsigned long frame_limit = acc_able_frame.x*window_frame + acc_able_frame.y;\n"
	"    \n"
	"    will_write = frame_limit<=my_index?0:frame_in[my_index];\n"
	"    will_write = rem<front_side_zero_padding_size?0:will_write;\n"
	"\n"
	"    frame_out[myid].x=will_write;\n"
	"    frame_out[myid].y=0;\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#ifndef DO_DEBUG\n"
	"//Release Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_RELEASE\n"
	"\n"
	"\n"
	"\n"
	"#ifdef DO_DEBUG\n"
	"//Debug Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_DEBUG\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string overlap = 
	"CL_C_kernel_files/overlap.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string split_high_band = 
	"__kernel void split_high_band(__global float* in_frame, __global float* high_out, int radix_2_half_size, int mid_high, int padded_size)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    long powed_limit = (int)pow(2.0,radix_2_half_size);\n"
	"    int my_locale_index = (myid % padded_size);\n"
	"    int my_global_index = myid / padded_size;\n"
	"    long my_index = powed_limit*my_global_index + my_locale_index + mid_high;\n"
	"    float for_write = my_locale_index>=mid_high?0:in_frame[my_index];\n"
	"    high_out[myid]=for_write;\n"
	"}\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string split_high_band = 
	"CL_C_kernel_files/split_high_band.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string split_low_band = 
	"__kernel void split_low_band(__global float* in_frame, __global float* low_out, int radix_2_half_size, int low_mid, int padded_size)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    long powed_limit = (long)pow(2.0,radix_2_half_size);\n"
	"    int my_locale_index = myid % padded_size;\n"
	"    int my_global_index = myid / padded_size;\n"
	"    long my_index = powed_limit * my_global_index + my_locale_index;\n"
	"    float for_write = my_locale_index>=low_mid?0.0:in_frame[my_index];\n"
	"    low_out[myid]=for_write;\n"
	"}\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string split_low_band = 
	"CL_C_kernel_files/split_low_band.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string split_mid_band = 
	"__kernel void split_mid_band(__global float* in_frame, __global float* mid_out, int radix_2_half_size, int low_mid, int mid_high, int padded_size)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    long powed_limit = (int)pow(2.0,radix_2_half_size);\n"
	"    int my_locale_index = (myid % padded_size);\n"
	"    int my_global_index = myid / padded_size;\n"
	"    long my_index = powed_limit*my_global_index + my_locale_index + low_mid;\n"
	"    float for_write = my_locale_index>=(mid_high-low_mid)?0:in_frame[my_index];\n"
	"    mid_out[myid]=for_write;\n"
	"}\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string split_mid_band = 
	"CL_C_kernel_files/split_mid_band.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string STFT = 
	"#define TIDX uint\n"
	"#define TIDX2 uint2\n"
	"#define FULL_LENGTH get_global_size(0)\n"
	"#define WINDOW_LENGTH get_local_size(0)\n"
	"#define GID get_global_id(0)\n"
	"#define LID get_local_id(0)\n"
	"typedef struct Dvals {\n"
	"    global float2* in;\n"
	"    global float* out;\n"
	"}DV;\n"
	"\n"
	"void DC_remover(__global short* in, __local atomic_int* sums)\n"
	"{\n"
	"    atomic_fetch_add(sums,convert_int(in[GID]));\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    in[GID] -= convert_short(atomic_load(sums)/WINDOW_LENGTH);\n"
	"}\n"
	"\n"
	"\n"
	"inline float \n"
	"window_func(const int index, const int window_size)\n"
	"{\n"
	"    return (0.42 - 0.5*cospi(2.0*(float)index/(float)window_size)+0.08*cospi(4.0*(float)index/(float)(window_size)));\n"
	"}\n"
	"\n"
	"void \n"
	"windowing(__global float2* in)\n"
	"{\n"
	"    in[GID].x = in[GID].x * window_func(LID, WINDOW_LENGTH);\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"inline int \n"
	"reverseBits(int num, int radix_2_data) {\n"
	"    private int reversed = 0;\n"
	"    for (int i = 0; i < radix_2_data; ++i) {\n"
	"        reversed = (reversed << 1) | (num & 1);\n"
	"        num >>= 1;\n"
	"    }\n"
	"    return reversed;\n"
	"}\n"
	"\n"
	"void \n"
	"bitreverse_stft(__global float2* in, int radix_2)\n"
	"{\n"
	"    private TIDX id_quot = GID / WINDOW_LENGTH;\n"
	"    TIDX calced_id = id_quot * WINDOW_LENGTH + reverseBits(LID, radix_2);\n"
	"    private TIDX2 tout;\n"
	"    tout.x = in[calced_id].x;\n"
	"    tout.y = 0.0;\n"
	"    barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    in[GID].x = tout.x;\n"
	"    in[GID].y = tout.y;\n"
	"}\n"
	"typedef float2 cfloat;\n"
	"\n"
	"#define I ((cfloat)(0.0, 1.0))\n"
	"\n"
	"inline float  real(cfloat a){\n"
	"     return a.x;\n"
	"}\n"
	"inline float  imag(cfloat a){\n"
	"     return a.y;\n"
	"}\n"
	"\n"
	"inline float cmod(cfloat a){\n"
	"    return (sqrt(a.x*a.x + a.y*a.y));\n"
	"}\n"
	"inline float carg(cfloat a){\n"
	"    if(a.x > 0){\n"
	"        return atan(a.y / a.x);\n"
	"\n"
	"    }else if(a.x < 0 && a.y >= 0){\n"
	"        return atan(a.y / a.x) + M_PI;\n"
	"\n"
	"    }else if(a.x < 0 && a.y < 0){\n"
	"        return atan(a.y / a.x) - M_PI;\n"
	"\n"
	"    }else if(a.x == 0 && a.y > 0){\n"
	"        return M_PI/2;\n"
	"\n"
	"    }else if(a.x == 0 && a.y < 0){\n"
	"        return -M_PI/2;\n"
	"\n"
	"    }else{\n"
	"        return 0;\n"
	"    }\n"
	"}\n"
	"\n"
	"inline cfloat  cmult(cfloat a, cfloat b){\n"
	"    return (cfloat)( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
	"}\n"
	"\n"
	"inline cfloat cdiv(cfloat a, cfloat b){\n"
	"    return (cfloat)((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y), (a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y));\n"
	"}\n"
	"cfloat twiddle(int high, int low)\n"
	"{\n"
	"    cfloat temp;\n"
	"    float angle = 2.0*((float)high/(float)low);\n"
	"    temp.x = cospi(angle);\n"
	"    temp.y = -1.0*sinpi(angle);\n"
	"    return temp;\n"
	"}\n"
	"TIDX2 indexer(const TIDX ID,const int powed_stage)\n"
	"{\n"
	"    private TIDX2 temp;\n"
	"    temp.x = (ID%(powed_stage))+powed_stage*2*(ID/powed_stage);\n"
	"    temp.y = temp.x+powed_stage;\n"
	"    return temp;\n"
	"}\n"
	"\n"
	"void \n"
	"butterfly_stft(__global float2* in, int radix_2)\n"
	"{\n"
	"    for(int stage = 0; stage < radix_2; ++stage){\n"
	"        if(GID < (FULL_LENGTH / 2)){\n"
	"            private TIDX powed_stage = (TIDX)pow(2.0, stage);\n"
	"            private TIDX2 origin_pair = indexer(GID, powed_stage);\n"
	"            private cfloat this_twiddle = twiddle(GID % powed_stage, powed_stage * 2);\n"
	"            this_twiddle = cmult(in[origin_pair.y],this_twiddle);\n"
	"            private float2 tempx;\n"
	"            private float2 tempy;\n"
	"            tempx = in[origin_pair.x] + this_twiddle;\n"
	"            tempy = in[origin_pair.y] - this_twiddle;\n"
	"            barrier(CLK_LOCAL_MEM_FENCE);\n"
	"            in[origin_pair.x] = tempx;\n"
	"            in[origin_pair.y] = tempy;\n"
	"        }\n"
	"        else{\n"
	"            barrier(CLK_LOCAL_MEM_FENCE);\n"
	"        }\n"
	"        barrier(CLK_LOCAL_MEM_FENCE);\n"
	"    }\n"
	"}\n"
	"#define HF_SZ(N) (N / 2)\n"
	"#define IDX(C, ID) ((ID / HF_SZ(C) * C) + (ID % HF_SZ(C)))\n"
	"void \n"
	"to_power(__global float2* in, __global float* out)\n"
	"{\n"
	"    if(GID < FULL_LENGTH / 2){\n"
	"        private float powered = cmod(in[IDX(FULL_LENGTH, GID)]);\n"
	"        out[GID] = powered;//GID % HF_SZ(core_size) < 2 ? 0 : powered;   \n"
	"    }\n"
	"}\n"
	"\n"
	"void normalization()\n"
	"{\n"
	"\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"__kernel void STFT( __global short* in,\n"
	"                    __global float2* tempBuffer,\n"
	"                    __global float* out,\n"
	"                    int overlapFrame,\n"
	"                    TIDX frameLimit,\n"
	"                    int FrontZeroPad,\n"
	"                    int windowRadix)\n"
	"{\n"
	"    local atomic_int dc_avg;\n"
	"    atomic_init(&dc_avg, 0);\n"
	"    DC_remover(in, &dc_avg);\n"
	"    private TIDX quot = GID / WINDOW_LENGTH;\n"
	"    private TIDX my_index = quot * overlapFrame + LID;\n"
	"    private float will_write;\n"
	"    \n"
	"    will_write = frameLimit <= my_index ? 0 : convert_float(in[my_index]);\n"
	"    will_write = LID < FrontZeroPad ? 0 : will_write;\n"
	"    tempBuffer[GID].x = will_write;\n"
	"    tempBuffer[GID].y = 0;\n"
	"    windowing(tempBuffer);\n"
	"    bitreverse_stft(tempBuffer, windowRadix);\n"
	"    butterfly_stft(tempBuffer, windowRadix);\n"
	"    to_power(tempBuffer, out);\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"__kernel void \n"
	"overlap(__global short* in,\n"
	"        __global float2* out,\n"
	"        int overlap_frame,\n"
	"        TIDX frame_limit, \n"
	"        int front_side_zero_padding_size)\n"
	"{\n"
	"    local atomic_int dc_avg;\n"
	"    atomic_init(&dc_avg, 0);\n"
	"    DC_remover(in, &dc_avg);\n"
	"    private TIDX quot = GID / WINDOW_LENGTH;\n"
	"    private TIDX my_index = quot * overlap_frame + LID;\n"
	"    private float will_write;\n"
	"    \n"
	"    will_write = frame_limit <= my_index ? 0 : convert_float(in[my_index]);\n"
	"    will_write = LID < front_side_zero_padding_size ? 0 : will_write;\n"
	"    out[GID].x = will_write;\n"
	"    out[GID].y = 0;\n"
	"}\n"
	"\n"
	"\n"
	"// __kernel void STFT(__global float2* in_frame, __global float* out_frame, int radix_window)\n"
	"// {\n"
	"    \n"
	"//     windowing(in_frame);\n"
	"//     bitreverse_stft(in_frame, radix_window);\n"
	"//     butterfly_stft(in_frame, radix_window);\n"
	"//     to_power(in_frame, out_frame);\n"
	"// }\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string STFT = 
	"CL_C_kernel_files/STFT.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string stft_entry_function = 
	"#define TIDX uint\n"
	"#define TIDX2 uint2\n"
	"typedef struct Dvals {\n"
	"    global float2* in;\n"
	"    global float* out;\n"
	"    TIDX full_length;\n"
	"    TIDX window_length;\n"
	"    TIDX idx;\n"
	"    TIDX loc_idx;\n"
	"}DV;\n"
	"\n"
	"__kernel void \n"
	"overlap(__global float* in,\n"
	"        __global float2* out,\n"
	"        int window_frame,\n"
	"        int overlap_frame, \n"
	"        TIDX frame_limit, \n"
	"        int front_side_zero_padding_size)\n"
	"{\n"
	"    private TIDX idx = get_global_id(0);\n"
	"    private TIDX quot =idx / window_frame;\n"
	"\n"
	"    private int rem = idx % window_frame;\n"
	"    private TIDX my_index = quot * overlap_frame + rem;\n"
	"    private float will_write;\n"
	"    \n"
	"    will_write = frame_limit <= my_index ? 0 : in[my_index];\n"
	"    will_write = rem < front_side_zero_padding_size ? 0 : will_write;\n"
	"    out[idx].x = will_write;\n"
	"    out[idx].y = 0;\n"
	"}\n"
	"\n"
	"\n"
	"inline float \n"
	"window_func(const int index, const int window_size)\n"
	"{\n"
	"    return (0.42 - 0.5*cospi(2.0*(float)index/(float)window_size)+0.08*cospi(4.0*(float)index/(float)(window_size)));\n"
	"}\n"
	"\n"
	"void \n"
	"windowing(DV db, int window_len)\n"
	"{\n"
	"    db.in[db.idx].x = db.in[db.idx].x * window_func(db.idx % window_len, window_len);\n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"inline int \n"
	"reverseBits(int num, int radix_2_data) {\n"
	"    private int reversed = 0;\n"
	"    for (int i = 0; i < radix_2_data; ++i) {\n"
	"        reversed = (reversed << 1) | (num & 1);\n"
	"        num >>= 1;\n"
	"    }\n"
	"    return reversed;\n"
	"}\n"
	"\n"
	"void \n"
	"bitreverse_stft(DV db, int window_len, int radix_2)\n"
	"{\n"
	"    private TIDX id_quot = db.idx / window_len;\n"
	"    private int id_rem = db.idx % window_len;\n"
	"    TIDX calced_id = id_quot * window_len + reverseBits(id_rem,radix_2);\n"
	"    private TIDX2 tout;\n"
	"    tout.x = db.in[calced_id].x;\n"
	"    tout.y = 0.0;\n"
	"    barrier(CLK_GLOBAL_MEM_FENCE);\n"
	"    db.in[db.idx].x = tout.x;\n"
	"    db.in[db.idx].y = tout.y;\n"
	"    // out_frame[myid].x = frame[calced_id].x;\n"
	"    // out_frame[myid].y = 0.0;\n"
	"\n"
	"}\n"
	"typedef float2 cfloat;\n"
	"\n"
	"#define I ((cfloat)(0.0, 1.0))\n"
	"\n"
	"inline float  real(cfloat a){\n"
	"     return a.x;\n"
	"}\n"
	"inline float  imag(cfloat a){\n"
	"     return a.y;\n"
	"}\n"
	"\n"
	"inline float cmod(cfloat a){\n"
	"    return (sqrt(a.x*a.x + a.y*a.y));\n"
	"}\n"
	"inline float carg(cfloat a){\n"
	"    if(a.x > 0){\n"
	"        return atan(a.y / a.x);\n"
	"\n"
	"    }else if(a.x < 0 && a.y >= 0){\n"
	"        return atan(a.y / a.x) + M_PI;\n"
	"\n"
	"    }else if(a.x < 0 && a.y < 0){\n"
	"        return atan(a.y / a.x) - M_PI;\n"
	"\n"
	"    }else if(a.x == 0 && a.y > 0){\n"
	"        return M_PI/2;\n"
	"\n"
	"    }else if(a.x == 0 && a.y < 0){\n"
	"        return -M_PI/2;\n"
	"\n"
	"    }else{\n"
	"        return 0;\n"
	"    }\n"
	"}\n"
	"\n"
	"inline cfloat  cmult(cfloat a, cfloat b){\n"
	"    return (cfloat)( a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n"
	"}\n"
	"\n"
	"inline cfloat cdiv(cfloat a, cfloat b){\n"
	"    return (cfloat)((a.x*b.x + a.y*b.y)/(b.x*b.x + b.y*b.y), (a.y*b.x - a.x*b.y)/(b.x*b.x + b.y*b.y));\n"
	"}\n"
	"cfloat twiddle(int high, int low)\n"
	"{\n"
	"    cfloat temp;\n"
	"    float angle = 2.0*((float)high/(float)low);\n"
	"    temp.x = cospi(angle);\n"
	"    temp.y = -1.0*sinpi(angle);\n"
	"    return temp;\n"
	"}\n"
	"TIDX2 indexer(const TIDX ID,const int stage)\n"
	"{\n"
	"    private TIDX2 temp;\n"
	"    private TIDX powed = pow(2.0, stage);\n"
	"    temp.x = (ID%(powed))+powed*2*(ID/powed);\n"
	"    temp.y = temp.x+powed;\n"
	"    return temp;\n"
	"}\n"
	"void \n"
	"butterfly_stft(DV db, int radix_2, TIDX core_size)\n"
	"{\n"
	"    for(int stage = 0; stage < radix_2; ++stage){\n"
	"        if(db.idx < (core_size / 2)){\n"
	"            private TIDX powed_stage = (TIDX)pow(2.0, stage);\n"
	"            private TIDX2 origin_pair=indexer(db.idx, stage);\n"
	"            private cfloat this_twiddle = twiddle(db.idx % powed_stage, powed_stage * 2);\n"
	"            this_twiddle = cmult(db.in[origin_pair.y],this_twiddle);\n"
	"            private float2 tempx;\n"
	"            private float2 tempy;\n"
	"            tempx = db.in[origin_pair.x] + this_twiddle;\n"
	"            tempy = db.in[origin_pair.y] - this_twiddle;\n"
	"            barrier(CLK_GLOBAL_MEM_FENCE);\n"
	"            db.in[origin_pair.x] = tempx;\n"
	"            db.in[origin_pair.y] = tempy;\n"
	"        }\n"
	"        else{\n"
	"            barrier(CLK_GLOBAL_MEM_FENCE);\n"
	"        }\n"
	"        barrier(CLK_GLOBAL_MEM_FENCE);\n"
	"    }\n"
	"}\n"
	"#define HF_SZ(N) (N / 2)\n"
	"#define IDX(C, ID) ((ID / HF_SZ(C) * C) + (ID % HF_SZ(C)))\n"
	"void \n"
	"to_power(DV db, TIDX core_size)\n"
	"{\n"
	"    if(db.idx < core_size / 2){\n"
	"        private float powered = cmod(db.in[IDX(core_size, db.idx)]);\n"
	"        db.out[db.idx]= db.idx % HF_SZ(core_size) < 2 ? 0 : powered;   \n"
	"    }\n"
	"}\n"
	"\n"
	"void normalization()\n"
	"{\n"
	"\n"
	"}\n"
	"\n"
	"void DC_remover(DV db)\n"
	"{\n"
	"    \n"
	"}\n"
	"\n"
	"\n"
	"__kernel void stft_entry_function(__global float2* in_frame, __global float* out_frame, int window_size, int radix_window, TIDX core_size)\n"
	"{\n"
	"    private DV dv;\n"
	"    dv.in = in_frame;\n"
	"    dv.out = out_frame;\n"
	"    dv.idx = get_global_id(0);\n"
	"    dv.loc_idx = get_local_id(0);\n"
	"    dv.full_length = get_global_size(0);\n"
	"    dv.window_length = get_local_size(0);\n"
	"    windowing(dv, window_size);\n"
	"    bitreverse_stft(dv, window_size, radix_window);\n"
	"    butterfly_stft(dv, radix_window, core_size);\n"
	"    to_power(dv, core_size);\n"
	"}\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string stft_entry_function = 
	"CL_C_kernel_files/STFT_entry.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string to_dbfs = 
	"//DEBUG OR RELEASE\n"
	"#define DO_DEBUG\n"
	"\n"
	"\n"
	"float dbfs(float powered, int window_origin_size, int added_size){\n"
	"    float result = 10.0 * log10(pow(powered,2) / (1.0 * (float)window_origin_size*(float)added_size));\n"
	"    \n"
	"    return result;\n"
	"}\n"
	"\n"
	"__kernel void to_dbfs(__global float3* in_frame, __global float3* out_frame, int window_radix_2, int low_size, int mid_size, int high_size)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    out_frame[myid].x = dbfs(in_frame[myid].x,window_radix_2,low_size);\n"
	"    out_frame[myid].y = dbfs(in_frame[myid].y,window_radix_2,mid_size);\n"
	"    out_frame[myid].z = dbfs(in_frame[myid].z,window_radix_2,high_size);\n"
	"    \n"
	"    \n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#ifndef DO_DEBUG\n"
	"//Release Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_RELEASE\n"
	"\n"
	"\n"
	"\n"
	"#ifdef DO_DEBUG\n"
	"//Debug Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_DEBUG\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string to_dbfs = 
	"CL_C_kernel_files/to_dbfs.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string to_power = 
	"//DEBUG OR RELEASE\n"
	"#define DO_DEBUG\n"
	"\n"
	"\n"
	"// inline float dbfs(float powered, int window_origin_size){\n"
	"//     float result = 10 * log10(pow(powered,2) / (1.0 * window_origin_size));\n"
	"//     return result;\n"
	"// }\n"
	"\n"
	"//Front declaration\n"
	"//declare here, implement later\n"
	"\n"
	"\n"
	"inline float cmod(float2 a){\n"
	"    return (sqrt(a.x*a.x + a.y*a.y));\n"
	"}\n"
	"\n"
	"__kernel void to_power(__global float2* in_frame, __global float* out_frame, int origin_size)\n"
	"{\n"
	"    long myid = get_global_id(0);\n"
	"    long half_size = (long)origin_size / 2;\n"
	"    long index = ((long)origin_size * ( myid / half_size )) + ( myid % half_size );\n"
	"    float powered =cmod(in_frame[index]);\n"
	"    powered = myid%half_size < 2?0:powered;\n"
	"    out_frame[myid]=powered;\n"
	"    \n"
	"    \n"
	"}\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#ifndef DO_DEBUG\n"
	"//Release Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_RELEASE\n"
	"\n"
	"\n"
	"\n"
	"#ifdef DO_DEBUG\n"
	"//Debug Codes\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"\n"
	"#endif //DO_DEBUG\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string to_power = 
	"CL_C_kernel_files/to_power.cl\n"
	;
#endif
#ifndef NO_EMBEDDED_CL
std::string windowing = 
	"\n"
	"\n"
	"inline float window_func(const int powed, const int index, const int window_size)\n"
	"{\n"
	"    return (0.42 - 0.5*cospi(2.0*(float)index/(float)window_size)+0.08*cospi(4.0*(float)index/(float)(window_size)));\n"
	"}\n"
	"\n"
	"__kernel void windowing(__global float2* frame_in, __global float2* frame_out, int window_radix_2_size)\n"
	"{\n"
	"    int powed = (int)pow(2.0,window_radix_2_size);\n"
	"    long myid = get_global_id(0);\n"
	"    frame_out[myid].x = frame_in[myid].x*window_func(powed,myid%powed,powed);\n"
	"    \n"
	"}\n"
	"\n"
	;
#endif
#ifdef NO_EMBEDDED_CL
std::string windowing = 
	"CL_C_kernel_files/windowing.cl\n"
	;
#endif

};